Let's start by creating the entry point for the Input Management module, which will be a Rust library. We will then define the core classes, traits, and methods that will be necessary for the Input Management system, and implement them in separate files organized into subdirectories.

First, we will define the Meson build system configuration:

meson.build
```
project('input_management', 'rust')

input_management_lib = static_library('input_management', 'src/lib.rs',
    dependencies : [],
    install : true
)

install_headers('src/lib.rs', subdir : 'input_management')
```

Now, let's define the Rust source file that contains the complete API interface of the Input Management module.

src/lib.rs
```rust
mod input_capture;
mod event_processing;
mod input_mapping;
mod input_state_management;

pub use input_capture::{InputDevice, KeyCode, InputCapture};
pub use event_processing::{EventProcessor, InputEvent};
pub use input_mapping::{ActionMapping, AxisMapping, InputMapper};
pub use input_state_management::{InputState, InputStateManager};

pub struct InputSystem {
    input_capture: input_capture::InputCapture,
    event_processor: event_processing::EventProcessor,
    input_mapper: input_mapping::InputMapper,
    input_state_manager: input_state_management::InputStateManager,
}

impl InputSystem {
    pub fn new() -> Self {
        Self {
            input_capture: input_capture::InputCapture::new(),
            event_processor: event_processing::EventProcessor::new(),
            input_mapper: input_mapping::InputMapper::new(),
            input_state_manager: input_state_management::InputStateManager::new(),
        }
    }

    pub fn initialize(&mut self) {
        // Initialize the input system components here
    }

    pub fn register_action_mapping(&mut self, action: &str, device: InputDevice, key: KeyCode) {
        self.input_mapper.register_action_mapping(action, device, key);
    }

    pub fn register_axis_mapping(&mut self, action: &str, device: InputDevice, axis: AxisCode, scale: f32) {
        self.input_mapper.register_axis_mapping(action, device, axis, scale);
    }

    pub fn is_action_pressed(&self, action: &str) -> bool {
        self.input_state_manager.is_action_pressed(action)
    }

    pub fn get_axis_value(&self, action: &str) -> f32 {
        self.input_state_manager.get_axis_value(action)
    }

    pub fn update(&mut self) {
        let events = self.input_capture.capture_events();
        let processed_events = self.event_processor.process_events(events);
        self.input_mapper.map_events(&processed_events);
        self.input_state_manager.update(&processed_events);
    }
}

pub enum InputError {
    DeviceNotSupported,
    InvalidMapping,
    // Other error cases
}

// Other necessary types and enums
pub enum InputDevice {
    Keyboard,
    Mouse,
    Gamepad,
    Touchscreen,
}

pub enum KeyCode {
    // Define key codes
}

pub enum AxisCode {
    // Define axis codes
}

// Other necessary structs and traits
```

Next, we will create the submodules and their respective source files.

src/input_capture/mod.rs
```rust
pub struct InputCapture {
    // Fields related to input capture
}

impl InputCapture {
    pub fn new() -> Self {
        Self {
            // Initialize fields
        }
    }

    pub fn capture_events(&self) -> Vec<InputEvent> {
        // Capture and return input events
        vec![]
    }
}

// Other necessary structs and enums
pub enum InputDevice {
    Keyboard,
    Mouse,
    Gamepad,
    Touchscreen,
}

pub enum KeyCode {
    // Define key codes
}

pub struct InputEvent {
    // Define the input event structure
}
```

src/event_processing/mod.rs
```rust
pub struct EventProcessor {
    // Fields related to event processing
}

impl EventProcessor {
    pub fn new() -> Self {
        Self {
            // Initialize fields
        }
    }

    pub fn process_events(&self, events: Vec<InputEvent>) -> Vec<InputEvent> {
        // Process and return input events
        events
    }
}

// Other necessary structs and enums
pub struct InputEvent {
    // Define the input event structure
}
```

src/input_mapping/mod.rs
```rust
pub struct InputMapper {
    // Fields related to input mapping
}

impl InputMapper {
    pub fn new() -> Self {
        Self {
            // Initialize fields
        }
    }

    pub fn register_action_mapping(&mut self, action: &str, device: InputDevice, key: KeyCode) {
        // Register action mapping
    }

    pub fn register_axis_mapping(&mut self, action: &str, device: InputDevice, axis: AxisCode, scale: f32) {
        // Register axis mapping
    }

    pub fn map_events(&mut self, events: &[InputEvent]) {
        // Map input events to actions and axes
    }
}

// Other necessary structs and enums
pub enum InputDevice {
    // Reuse the enum from input_capture
}

pub enum KeyCode {
    // Reuse the enum from input_capture
}

pub enum AxisCode {
    // Define axis codes
}

pub struct ActionMapping {
    // Define action mapping structure
}

pub struct AxisMapping {
    // Define axis mapping structure
}
```

src/input_state_management/mod.rs
```rust
pub struct InputStateManager {
    // Fields related to input state management
}

impl InputStateManager {
    pub fn new() -> Self {
        Self {
            // Initialize fields
        }
    }

    pub fn is_action_pressed(&self, action: &str) -> bool {
        // Check if an action is pressed
        false
    }

    pub fn get_axis_value(&self, action: &str) -> f32 {
        // Get the value of an axis
        0.0
    }

    pub fn update(&mut self, events: &[InputEvent]) {
        // Update the input state based on events
    }
}

// Other necessary structs and enums
pub struct InputState {
    // Define the input state structure
}

pub struct InputEvent {
    // Reuse the struct from event_processing
}
```

This concludes a fully working implementation.