### Software Design Document for Green Threads Job System

#### Introduction

This document outlines the design for a job system that leverages the concept of green threads to optimize CPU core utilization and minimize context switching. The system will be developed in C/C++ and utilize Meson as the build system. The architecture is designed to dynamically adapt to the hardware it's running on by querying the number of CPU cores and spawning an equivalent number of long-living threads, each bound to a specific core. This document serves as a guideline for the project team to implement the system.

#### System Overview

- **Objective**: To design a high-performance job system that minimizes context switching by utilizing green threads.
- **Compiler**: GCC or Clang supporting C++20 or later.
- **Key Libraries**: hwloc (for sticky threads), Boost.Thread (for thread pool management), Boost.Fiber (for implementing fibers as jobs)
- **Features**:
  - Detection of CPU cores at initialization.
  - Spawning of a thread pool matching the number of CPU cores.
  - Binding each thread to a specific CPU core.
  - A global queue for managing jobs (fibers) dynamically added at runtime.
  - Efficient scheduling of jobs across threads.
  - Support for stateful jobs that can execute other jobs and wait for results.
- **Build System**: Meson (create meson.build for this project with all sources and dependencies)

#### System Components

1. **Core Detector**:

   - **Functionality**: Detects the number of CPU cores at system initialization.
   - **Implementation**: Utilizes `hwloc` to determine `num_cores`.

2. **Thread Pool Manager**:

   - **Functionality**: Manages the lifecycle of worker threads with an emphasis on thread affinity to specific CPU cores.
   - **Components**:
     - **Initializer**: Responsible for spawning `num_cores` threads and setting thread affinity to bind each thread to its respective CPU core using the `hwloc` library. This ensures that each thread runs on a specific core, optimizing CPU cache usage and minimizing context switching.
     - **Scheduler**: Assigns jobs to threads, taking into account the thread affinity to ensure that each job is executed on the intended core.
     - **Terminator**: Gracefully shuts down threads, ensuring that thread affinity settings do not interfere with system operations post termination.

3. **Job Queue**:

   - **Functionality**: Holds jobs that are waiting to be executed.
   - **Features**:
     - Dynamically adding jobs at runtime.
     - Efficient retrieval mechanism for job scheduling.

4. **Job (Fiber) Manager**:
   - **Functionality**: Manages the lifecycle of jobs.
   - **Features**:
     - Stateful job execution.
     - Ability for jobs to spawn other jobs and wait for their completion.

#### Implementation Details

1. **Initialization Phase**:

   - Use `hwloc` to not only determine `num_cores` but also to retrieve detailed information about the CPU topology. This information is used to bind each of the `num_cores` worker threads to a specific CPU core, effectively setting the thread affinity.
   - This process involves creating a `hwloc` CPU set for each thread, which specifies the CPU core to which the thread should be bound. The `hwloc` API then applies this CPU set to the newly created threads, ensuring that each thread is affinitized to its designated core.

2. **Job Scheduling and Execution**:

   - Implement the job queue using efficient data structures to support quick enqueue and dequeue operations.
   - Use `boost::fibers` for implementing jobs, allowing for cooperative multitasking and efficient context switching within threads.
   - Develop a scheduler within the Thread Pool Manager to distribute jobs across the worker threads. The scheduling algorithm should consider job priorities and thread workloads to optimize execution times.
   - Ensure that once a worker thread is bound to a specific core, all jobs executed by this thread are run on the same core, maintaining the efficiency gains achieved through thread affinity.
   - The scheduler is designed to consider thread affinity as a primary factor when assigning jobs to threads, ensuring that jobs are executed on their assigned cores.
   - For load balancing, the scheduler also considers the current job queue length for each thread, ensuring no single core is overloaded.

3. **Job Creation and Management**:

   - Design jobs as fibers that can be easily created, executed, and synchronized within the worker threads.
   - Ensure jobs are stateful and support spawning and waiting for other jobs as part of their execution.

4. **Build System Configuration**:

   - Configure Meson to manage project dependencies (hwloc, Boost.Thread, and Boost.Fiber) and build settings for different environments.

5. **Testing**:
   - Implement unit tests for individual components (Core Detector, Thread Pool Manager, Job Queue, Job Manager).
   - Develop integration tests that simulate real-world scenarios with thousands of simple stateful jobs to verify the system's performance and stability.

### Additional Considerations for Thread Affinity

- **Monitoring and Performance Tuning**: Include monitoring capabilities to assess the impact of thread affinity on performance, collecting metrics such as CPU utilization, context switch rate, and job execution times.
- **Cross-Platform Compatibility**: Ensure the implementation of thread affinity is compatible across different operating systems and hardware architectures, potentially requiring conditional compilation or runtime checks.
- **Fallback Mechanism**: Provide a fallback mechanism in environments where setting thread affinity is not supported or feasible, allowing the system to maintain functionality and performance.

#### Example/Test Code

- Provide sample code that demonstrates the creation and management of a thousand simple, stateful jobs within the system, including examples of jobs that execute other jobs and wait for results.

#### Conclusion

This software design document presents a detailed blueprint for building a green threads-based job system optimized for CPU core utilization. Following this document, the project team can develop a robust, efficient job scheduling system that minimizes processor context switching and fully leverages the hardware capabilities.
