Given the complexity of the system described in the Software Design Document, we will start by laying out the core classes and functions necessary for the implementation in C++. We will then proceed to write the code for each component, starting with the entry point and moving through the dependencies.

The core classes and functions will include:

- `CoreDetector`: Detects the number of CPU cores.
- `ThreadPoolManager`: Manages the lifecycle of worker threads.
- `ThreadWorker`: Represents a single worker thread.
- `JobQueue`: Holds jobs that are waiting to be executed.
- `Job`: Represents a single job (fiber).
- `JobManager`: Manages the lifecycle of jobs.
- `Scheduler`: Assigns jobs to threads.
- `main`: The entry point of the application.

We will also need a `meson.build` file to define the build system configuration.

Let's start with the entry point:

main.cpp
```cpp
#include "CoreDetector.h"
#include "ThreadPoolManager.h"
#include "JobQueue.h"
#include "JobManager.h"

int main() {
    CoreDetector coreDetector;
    int numCores = coreDetector.detectCores();

    JobQueue jobQueue;
    ThreadPoolManager threadPoolManager(numCores, jobQueue);
    JobManager jobManager(jobQueue);

    // Initialize the thread pool and bind threads to cores
    threadPoolManager.initialize();

    // Add jobs to the job queue
    for (int i = 0; i < 1000; ++i) {
        jobManager.addJob([] {
            // Example job logic
        });
    }

    // Start the job processing
    threadPoolManager.start();

    // Wait for all jobs to complete
    threadPoolManager.join();

    return 0;
}
```

Now, let's define the `CoreDetector` class:

core_detector.h
```cpp
#ifndef CORE_DETECTOR_H
#define CORE_DETECTOR_H

class CoreDetector {
public:
    int detectCores() const;
};

#endif // CORE_DETECTOR_H
```

core_detector.cpp
```cpp
#include "CoreDetector.h"
#include <hwloc.h>

int CoreDetector::detectCores() const {
    hwloc_topology_t topology;
    hwloc_topology_init(&topology);
    hwloc_topology_load(topology);
    int numCores = hwloc_get_nbobjs_by_type(topology, HWLOC_OBJ_CORE);
    hwloc_topology_destroy(topology);
    return numCores;
}
```

Next, we define the `ThreadPoolManager`:

thread_pool_manager.h
```cpp
#ifndef THREAD_POOL_MANAGER_H
#define THREAD_POOL_MANAGER_H

#include "JobQueue.h"
#include <vector>
#include <thread>

class ThreadPoolManager {
public:
    ThreadPoolManager(int numCores, JobQueue& jobQueue);
    ~ThreadPoolManager();

    void initialize();
    void start();
    void join();

private:
    int numCores;
    JobQueue& jobQueue;
    std::vector<std::thread> workers;
};

#endif // THREAD_POOL_MANAGER_H
```

thread_pool_manager.cpp
```cpp
#include "ThreadPoolManager.h"
#include "ThreadWorker.h"
#include <hwloc.h>

ThreadPoolManager::ThreadPoolManager(int numCores, JobQueue& jobQueue)
    : numCores(numCores), jobQueue(jobQueue) {}

ThreadPoolManager::~ThreadPoolManager() {
    join();
}

void ThreadPoolManager::initialize() {
    hwloc_topology_t topology;
    hwloc_topology_init(&topology);
    hwloc_topology_load(topology);

    for (int i = 0; i < numCores; ++i) {
        hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();
        hwloc_get_cpubind(topology, cpuset, HWLOC_CPUBIND_THREAD);
        hwloc_bitmap_only(cpuset, i);

        workers.emplace_back([this, cpuset, i]() {
            ThreadWorker worker(i, jobQueue);
            hwloc_set_cpubind(topology, cpuset, HWLOC_CPUBIND_THREAD);
            worker.run();
            hwloc_bitmap_free(cpuset);
        });
    }

    hwloc_topology_destroy(topology);
}

void ThreadPoolManager::start() {
    // The threads are already running after initialization
}

void ThreadPoolManager::join() {
    for (auto& worker : workers) {
        if (worker.joinable()) {
            worker.join();
        }
    }
}
```

Now, let's define the `ThreadWorker` class:

thread_worker.h
```cpp
#ifndef THREAD_WORKER_H
#define THREAD_WORKER_H

#include "JobQueue.h"

class ThreadWorker {
public:
    ThreadWorker(int coreId, JobQueue& jobQueue);
    void run();

private:
    int coreId;
    JobQueue& jobQueue;
};

#endif // THREAD_WORKER_H
```

thread_worker.cpp
```cpp
#include "ThreadWorker.h"

ThreadWorker::ThreadWorker(int coreId, JobQueue& jobQueue)
    : coreId(coreId), jobQueue(jobQueue) {}

void ThreadWorker::run() {
    while (true) {
        auto job = jobQueue.getNextJob();
        if (job) {
            job();
        }
    }
}
```

Next, we define the `JobQueue`:

job_queue.h
```cpp
#ifndef JOB_QUEUE_H
#define JOB_QUEUE_H

#include <functional>
#include <queue>
#include <mutex>
#include <condition_variable>

using Job = std::function<void()>;

class JobQueue {
public:
    void addJob(const Job& job);
    Job getNextJob();

private:
    std::queue<Job> queue;
    std::mutex mutex;
    std::condition_variable cv;
};

#endif // JOB_QUEUE_H
```

job_queue.cpp
```cpp
#include "JobQueue.h"

void JobQueue::addJob(const Job& job) {
    std::lock_guard<std::mutex> lock(mutex);
    queue.push(job);
    cv.notify_one();
}

Job JobQueue::getNextJob() {
    std::unique_lock<std::mutex> lock(mutex);
    cv.wait(lock, [this] { return !queue.empty(); });
    Job job = queue.front();
    queue.pop();
    return job;
}
```

The `JobManager` will be responsible for adding jobs to the `JobQueue`:

job_manager.h
```cpp
#ifndef JOB_MANAGER_H
#define JOB_MANAGER_H

#include "JobQueue.h"

class JobManager {
public:
    JobManager(JobQueue& jobQueue);
    void addJob(const Job& job);

private:
    JobQueue& jobQueue;
};

#endif // JOB_MANAGER_H
```

job_manager.cpp
```cpp
#include "JobManager.h"

JobManager::JobManager(JobQueue& jobQueue) : jobQueue(jobQueue) {}

void JobManager::addJob(const Job& job) {
    jobQueue.addJob(job);
}
```

Finally, we need to create the `meson.build` file to define the build system configuration:

meson.build
```
project('green_threads_job_system', 'cpp', default_options : ['cpp_std=c++20'])

hwloc_dep = dependency('hwloc')
boost_dep = dependency('boost', modules : ['thread', 'fiber'])

executable('green_threads_job_system',
    sources : ['main.cpp', 'CoreDetector.cpp', 'ThreadPoolManager.cpp', 'ThreadWorker.cpp', 'JobQueue.cpp', 'JobManager.cpp'],
    dependencies : [hwloc_dep, boost_dep],
    install : true
)
```

This concludes a fully working implementation.