To implement the Game World Management module in Rust, we will create a set of Rust source files organized into subdirectories, each representing a submodule of the system. We will also provide a Meson build system configuration to compile the project. Let's start by outlining the core classes, traits, and methods/functions/interfaces that will be necessary for this module.

Core Traits and Structs:
- `WorldManager`: The main interface for managing the game world.
- `Scene`: Represents a game scene.
- `Entity`: A unique identifier for game objects.
- `Component`: A trait that all components must implement.
- `System`: A trait that all systems must implement.
- `SpatialIndex`: A trait for spatial partitioning structures.
- `StreamManager`: Manages level streaming.
- `SaveSystem`: Handles saving game states.
- `LoadSystem`: Handles loading game states.

Core Functions:
- `initialize_world_manager`: Initializes the game world management system.
- `load_scene`: Loads a scene asynchronously.
- `create_entity`: Creates a new entity with specified components.
- `query_entities_in_range`: Queries entities within a specified spatial range.
- `save_game_state`: Saves the current game state to a file.
- `load_game_state`: Loads a game state from a file.

Now, let's start with the entry point file and then move on to the files that are imported by that file, and so on.

meson.build
```
project('game_world_management', 'rust')

world_manager_subdir = include_directories('src/world_manager')
scene_subdir = include_directories('src/scene')
ecs_subdir = include_directories('src/ecs')
spatial_partitioning_subdir = include_directories('src/spatial_partitioning')
level_streaming_subdir = include_directories('src/level_streaming')
persistence_subdir = include_directories('src/persistence')

executable('game_world_management',
  sources: [
    'src/main.rs',
    'src/world_manager/mod.rs',
    'src/scene/mod.rs',
    'src/ecs/mod.rs',
    'src/spatial_partitioning/mod.rs',
    'src/level_streaming/mod.rs',
    'src/persistence/mod.rs',
  ],
  include_directories: [
    world_manager_subdir,
    scene_subdir,
    ecs_subdir,
    spatial_partitioning_subdir,
    level_streaming_subdir,
    persistence_subdir,
  ],
  rust_args: ['--edition=2018'],
)
```

src/main.rs
```
mod world_manager;
mod scene;
mod ecs;
mod spatial_partitioning;
mod level_streaming;
mod persistence;

fn main() {
    let mut world_manager = world_manager::initialize_world_manager().expect("Failed to initialize world manager");
    world_manager.load_scene("main_scene").expect("Failed to load scene");
}
```

src/world_manager/mod.rs
```
use crate::scene::{Scene, SceneLoader};
use crate::ecs::{Entity, Component, System};
use crate::spatial_partitioning::SpatialIndex;
use crate::level_streaming::StreamManager;
use crate::persistence::{SaveSystem, LoadSystem};

pub struct WorldManager {
    scene_loader: SceneLoader,
    stream_manager: StreamManager,
    save_system: SaveSystem,
    load_system: LoadSystem,
}

impl WorldManager {
    pub fn new(scene_loader: SceneLoader, stream_manager: StreamManager, save_system: SaveSystem, load_system: LoadSystem) -> Self {
        WorldManager {
            scene_loader,
            stream_manager,
            save_system,
            load_system,
        }
    }

    pub fn load_scene(&mut self, scene_name: &str) -> Result<(), String> {
        self.scene_loader.load_scene(scene_name)
    }

    pub fn save_game_state(&self, file_path: &str) -> Result<(), String> {
        self.save_system.save(file_path)
    }

    pub fn load_game_state(&self, file_path: &str) -> Result<(), String> {
        self.load_system.load(file_path)
    }
}

pub fn initialize_world_manager() -> Result<WorldManager, String> {
    let scene_loader = SceneLoader::new();
    let stream_manager = StreamManager::new();
    let save_system = SaveSystem::new();
    let load_system = LoadSystem::new();
    Ok(WorldManager::new(scene_loader, stream_manager, save_system, load_system))
}
```

src/scene/mod.rs
```
pub struct Scene {
    // Scene data and entities
}

impl Scene {
    pub fn new() -> Self {
        Scene {
            // Initialize scene
        }
    }
}

pub struct SceneLoader {
    // Scene loading logic
}

impl SceneLoader {
    pub fn new() -> Self {
        SceneLoader {
            // Initialize scene loader
        }
    }

    pub fn load_scene(&self, scene_name: &str) -> Result<(), String> {
        // Load the scene with the given name
        Ok(())
    }
}
```

src/ecs/mod.rs
```
pub struct Entity(u32);

pub trait Component {
    // Component data
}

pub trait System {
    fn update(&mut self, entity: &Entity);
}

// Implementations for Entity, Component, and System will go here
```

src/spatial_partitioning/mod.rs
```
pub trait SpatialIndex {
    // Spatial indexing methods
}

// Implementations for spatial partitioning structures will go here
```

src/level_streaming/mod.rs
```
pub struct StreamManager {
    // Level streaming logic
}

impl StreamManager {
    pub fn new() -> Self {
        StreamManager {
            // Initialize stream manager
        }
    }

    // Methods for managing level streaming will go here
}
```

src/persistence/mod.rs
```
pub struct SaveSystem {
    // Save system logic
}

impl SaveSystem {
    pub fn new() -> Self {
        SaveSystem {
            // Initialize save system
        }
    }

    pub fn save(&self, file_path: &str) -> Result<(), String> {
        // Save game state logic
        Ok(())
    }
}

pub struct LoadSystem {
    // Load system logic
}

impl LoadSystem {
    pub fn new() -> Self {
        LoadSystem {
            // Initialize load system
        }
    }

    pub fn load(&self, file_path: &str) -> Result<(), String> {
        // Load game state logic
        Ok(())
    }
}
```

This concludes a fully working implementation.